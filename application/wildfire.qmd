---
title: "BLAST Application"
author: "Johnny Myung Won Lee"
date: "2026-01-01"
date-format: "long"
format: 
  pdf:
    code-line-numbers: true
editor : visual
highlight-style: atom-one
---

```{r}
library(npreg)
library(Pareto)
suppressMessages(library(tidyverse))
library(readxl)
library(gridExtra)
# library(VGAM)
library(evgam)
library(qgam)
library(mgcViz)
```

```{r}
# Structure of the FWI System
#DSR : Daily Severity Rating
#FWI : Fire Weather Index
#BUI : Buildup Index
#ISI : Initial Spread Index
#FFMC : Fine FUel Moisture Code
#DMC : Duff Moisture Code
#DC : Drought Code
setwd("C:/Users/Johnny Lee/Documents/GitHub")
# setwd("A:/GitHub")
load("./BLAST/application/wildfire_prep.Rdata") #loading covariate-dependent thresholds
# load("./BLAST/application/quant975_prep.Rdata")
```

```{r, setup}
psi <- 30
u <- quantile(Y, 0.975)
y <- Y[which(Y>u)]
fwi.scaled <- fwi.origin[which(Y>u),c(1:7)]
range01 <- function(x){(x-min(x))/(max(x)-min(x))}
fwi.scaled <- as.data.frame(sapply(fwi.scaled, FUN = range01))
n <- dim(fwi.scaled)[[1]]
p <- dim(fwi.scaled)[[2]]
fwi.df <- data.frame(fwi.scaled, BA=y)
evgam.df <- data.frame(fwi.scaled, BA=y-u)
# xholder <- data.frame(matrix(nrow=n, ncol=p))
# for(i in 1:p){
#   xholder[,i] <- seq(min(fwi.scaled[,i]), max(fwi.scaled[,i]), length.out = n)
# }
xholder <- data.frame(sapply(1:p, function(i) seq(min(fwi.scaled[,i]), max(fwi.scaled[,i]), length.out = n)))
colnames(xholder) <- colnames(fwi.scaled)
```

```{r, evgam.scale}
gam.scale <- list(BA ~ s(DSR,  bs = "tp", k = 30) + 
                       s(FWI,  bs = "tp", k = 30) + 
                       s(BUI,  bs = "tp", k = 30) +
                       s(ISI,  bs = "tp", k = 30) + 
                       s(FFMC, bs = "tp", k = 30) + 
                       s(DMC,  bs = "tp", k = 30) +
                       s(DC,   bs = "tp", k = 30),
                     ~ s(DSR,  bs = "tp", k = 30) + 
                       s(FWI,  bs = "tp", k = 30) + 
                       s(BUI,  bs = "tp", k = 30) +
                       s(ISI,  bs = "tp", k = 30) + 
                       s(FFMC, bs = "tp", k = 30) + 
                       s(DMC,  bs = "tp", k = 30) +
                       s(DC,   bs = "tp", k = 30))
evgam.fit.scale <- evgam::evgam(gam.scale, dat = evgam.df, family = "gpd")
evgam.xi.scale <- predict(evgam.fit.scale, newdata = data.frame(xholder), type="response")$shape
evgam.scale.response <- predict(evgam.fit.scale, type = "response")

xholder.basis.scale <- predict(evgam.fit.scale, newdata = data.frame(xholder), type= "lpmatrix")$shape
xi.coef.scale <- tail(evgam.fit.scale$coefficients, (psi-1)*p)
gamma.xi.scale <- matrix(xi.coef.scale, ncol = p)
alpha.nonlinear.scale <- evgam.smooth.scale <- matrix(, nrow = n, ncol = p)
bs.nonlinear.scale <- xholder.basis.scale[,c(2:((psi-1)*p+1))]
for(j in 1:p){
  evgam.smooth.scale[,j] <- bs.nonlinear.scale[,(((j-1)*(psi-1))+1):(((j-1)*(psi-1))+(psi-1))] %*% gamma.xi.scale[,j]
  alpha.nonlinear.scale[,j] <- 1/(evgam.smooth.scale[,j])
}
```

```{r, evgam.1}
gam.1 <- list(BA ~ 1,
                 ~ s(DSR,  bs = "tp", k = 30) + 
                   s(FWI,  bs = "tp", k = 30) + 
                   s(BUI,  bs = "tp", k = 30) +
                   s(ISI,  bs = "tp", k = 30) + 
                   s(FFMC, bs = "tp", k = 30) + 
                   s(DMC,  bs = "tp", k = 30) +
                   s(DC,   bs = "tp", k = 30))
evgam.fit.1 <- evgam::evgam(gam.1, data = evgam.df, family = "gpd")
evgam.xi.1 <-predict(evgam.fit.1, newdata = data.frame(xholder), type="response")$shape
evgam.alpha.1 <- 1/evgam.xi.1
evgam.1.response <- predict(evgam.fit.1, type = "response")

xholder.basis.1 <- predict(evgam.fit.1, newdata = data.frame(xholder), type= "lpmatrix")$shape
xi.coef.1 <- tail(evgam.fit.1$coefficients, (psi-1)*p)
gamma.xi.1 <- matrix(xi.coef.1, ncol = p)
alpha.nonlinear.1 <- evgam.smooth.1 <- matrix(, nrow = n, ncol = p)
bs.nonlinear.1 <- xholder.basis.1[,c(2:((psi-1)*p+1))]
for(j in 1:p){
  evgam.smooth.1[,j] <- bs.nonlinear.1[,(((j-1)*(psi-1))+1):(((j-1)*(psi-1))+(psi-1))] %*% gamma.xi.1[,j]
  alpha.nonlinear.1[,j] <- 1/(evgam.smooth.1[,j])
}
```

```{r}
setwd("~/GitHub/BLAST/application")
load("blast.Rdata")
```

```{r}
xi.scenario <- data.frame("x" = xholder[,1],
                          # "vgam.1" = as.vector(vgam.xi.1),
                          # "vgam.scale" = as.vector(vgam.xi.scale),
                          "evgam.1" = as.vector(evgam.xi.1),
                          "evgam.scale" = as.vector(evgam.xi.scale),
                          "post.mean" = 1/data.scenario$post.mean,
                          "post.median" = 1/data.scenario$post.median,
                          "q1" = 1/data.scenario$q1,
                          "q3" = 1/data.scenario$q3)
ggplot(xi.scenario, aes(x=x)) + 
  ylab(expression(xi(c,ldots,c))) + xlab(expression(c)) + labs(col = "") +  
  geom_ribbon(aes(ymin = q1, ymax = q3, fill="Credible Band"), alpha = 0.2) +
  geom_line(aes(y=post.median, col = "Posterior Median"), linewidth=1) +
  # geom_line(aes(y=vgam.1), linewidth=1, color = "orange") +
  # geom_line(aes(y=vgam.scale), linewidth=1, color = "purple") +
  geom_line(aes(y=evgam.1), linewidth=1, color = "orange", linetype=3) +
  geom_line(aes(y=evgam.scale), linewidth=1, color = "purple", linetype=3) +  
  scale_fill_manual(values=c("steelblue"), name = "") +
  scale_color_manual(values = c("steelblue")) + 
  guides(color = guide_legend(order = 2), 
          fill = guide_legend(order = 1)) +
  theme_minimal(base_size = 30) +
  theme(legend.position = "none",
        strip.text = element_blank(),
        axis.text = element_text(size = 20))
```

```{r}
alpha.scenario <- data.frame("x" = xholder[,1],
                            #  "vgam.1" = 1/as.vector(vgam.xi.1),
                            #  "vgam.scale" = 1/as.vector(vgam.xi.scale),
                             "evgam.1" = 1/as.vector(evgam.xi.1),
                             "evgam.scale" = 1/as.vector(evgam.xi.scale),
                             "post.mean" = data.scenario$post.mean,
                             "post.median" = data.scenario$post.median,
                             "q1" = data.scenario$q1,
                             "q3" = data.scenario$q3)

ggplot(alpha.scenario, aes(x=x)) + 
  ylab(expression(alpha(c,ldots,c))) + xlab(expression(c)) + labs(col = "") + ylim(0,14.5)+
  geom_ribbon(aes(ymin = q1, ymax = q3, fill="Credible Band"), alpha = 0.2) +
  geom_line(aes(y=post.median, col = "Posterior Median"), linewidth=1) +  
  # geom_line(aes(y=vgam.1), linewidth=1, color = "orange") +
  # geom_line(aes(y=vgam.scale), linewidth=1, color = "purple") +
  geom_line(aes(y=evgam.1), linewidth=1, color = "orange", linetype=3) +
  geom_line(aes(y=evgam.scale), linewidth=1, color = "purple", linetype=3) +
  scale_fill_manual(values=c("steelblue"), name = "") +
  scale_color_manual(values = c("steelblue")) +   
  guides(color = guide_legend(order = 2), 
          fill = guide_legend(order = 1)) +
  theme_minimal(base_size = 30) +
  theme(legend.position = "none",
        strip.text = element_blank(),
        axis.text = element_text(size = 20))
```

```{r}
r.vgam.1 <- r.vgam.scale <- r.evgam.1 <- r.evgam.scale <- c()
for(i in 1:n){
    # r.vgam.1[i] <- qnorm(evd::pgpd(y[i], scale = exp(vgam.1.response[i,1]), loc = u, shape = exp(vgam.1.response[i,2])))
    # r.vgam.scale[i] <- qnorm(evd::pgpd(y[i], scale = exp(vgam.scale.response[i,1]), loc = u, shape = exp(vgam.scale.response[i,2])))
    r.evgam.1[i] <- qnorm(evd::pgpd(y[i]-u, scale = evgam.1.response$scale[i], loc = 0, shape = evgam.1.response$shape[i]))
    r.evgam.scale[i] <- qnorm(evd::pgpd(y[i]-u, scale = evgam.scale.response$scale[i], loc = 0, shape = evgam.scale.response$shape[i]))
}
lgrid <- n
quantile.prob <- ppoints(lgrid)
grid <- qnorm(quantile.prob)
# traj.vgam.1 <- traj.vgam.scale <- traj.evgam.1 <- traj.evgam.scale <- c()
# qqplot.df$traj.vgam.1 <- quantile(r.vgam.1, quantile.prob, type = 2)
# qqplot.df$traj.vgam.scale <- quantile(r.vgam.scale, quantile.prob, type = 2)
qqplot.df$traj.evgam.1 <- quantile(r.evgam.1, quantile.prob, type = 2)
qqplot.df$traj.evgam.scale <- quantile(r.evgam.scale, quantile.prob, type = 2)

ggplot(data = qqplot.df, aes(x=grid)) + 
  geom_ribbon(aes(ymin = l.band, ymax = u.band), 
              fill = "steelblue",
              alpha = 0.4, linetype = "dashed") + 
  geom_line(aes(y = trajhat), colour = "steelblue", linetype = "dashed", linewidth = 1.2) + 
  # geom_line(aes(y = traj.vgam.1), colour = "orange", linewidth=1.1) +
  # geom_line(aes(y = traj.vgam.scale), colour = "purple", linewidth=1.1) +
  geom_line(aes(y = traj.evgam.1), colour = "orange", linetype = 3, linewidth=1.1) +
  geom_line(aes(y = traj.evgam.scale), colour = "purple", linetype = 3, linewidth=1.1) +
  geom_abline(intercept = 0, slope = 1, linewidth = 1.2) + 
  labs(x = "Theoretical quantiles", y = "Sample quantiles") + 
  theme_minimal(base_size = 30) +
  theme(axis.text = element_text(size = 10)) + 
  coord_fixed(xlim = c(-3, 3),
              ylim = c(-3, 3))
```


```{r}

xi.smooth <- data.frame("x"= as.vector(as.matrix(xholder)),
                          "true" = as.vector(as.matrix(fwi.scaled)),
                          "mean" = data.smooth$post.mean,
                          "q1" = data.smooth$q1,
                          "q2" = data.smooth$q2,
                          "q3" = data.smooth$q3,
                          # "vgam.1" = as.vector(vgam.smooth.1),
                          # "vgam.scale" = as.vector(vgam.smooth.scale),
                          "evgam.1" = as.vector(evgam.smooth.1),
                          "evgam.scale" = as.vector(evgam.smooth.scale),
                          "covariates" = gl(p, n, (p*n), labels = names(fwi.scaled)),
                          "replicate" = gl(p, n, (p*n), labels = names(fwi.scaled)))

grid.plts <- list()
for(i in 1:p){
  grid.plt <- ggplot(data = data.frame(xi.smooth[((((i-1)*n)+1):(i*n)),]), aes(x=x)) + ylim(-6, 5) +
                  geom_hline(yintercept = 0, linetype = 2, color = "darkgrey", linewidth = 2) + 
                  geom_ribbon(aes(ymin = q1, ymax = q3), fill="steelblue", alpha = 0.2) +
                  geom_line(aes(y=q2, color = "BLAST", linetype="BLAST"), linewidth=1) + 
                  # geom_line(aes(y=vgam.1, color = "VGAM (fixed scale)", linetype="VGAM (fixed scale)"), linewidth = 1) + 
                  # geom_line(aes(y=vgam.scale, color = "VGAM",  linetype="VGAM"), linewidth=1,) + 
                  geom_line(aes(y=evgam.1, color = "EVGAM (fixed scale)", linetype="EVGAM (fixed scale)"), linewidth=1) + 
                  geom_line(aes(y=evgam.scale, color = "EVGAM", linetype="EVGAM"), linewidth=1) + 
                  ylab("") + xlab(names(fwi.scaled)[i]) +
                  geom_rug(aes(x=true, y=mean), sides = "b") + 
                  scale_color_manual(
                    name = "Method",
                    values = c("BLAST" = "steelblue",
                              # "VGAM (fixed scale)" = "orange",
                              # "VGAM" = "purple",
                              "EVGAM (fixed scale)" = "orange",
                              "EVGAM" = "purple")
                  ) +
                  scale_linetype_manual(
                    name = "Method",
                    values = c("BLAST" = "solid",
                              # "VGAM (fixed scale)" = "solid",
                              # "VGAM" = "solid",
                              "EVGAM (fixed scale)" = "dotted",
                              "EVGAM" = "dotted")
                  ) +
                  theme_minimal(base_size = 30) +
                  theme(legend.position = "right",
                          legend.text = element_text(size = 13),
                          legend.title = element_text(size = 13, face="bold"),
                          # legend.key.width = unit(0.2, "cm"),
                          # legend.key.height = unit(0.8, "cm"),
                          plot.margin = margin(0,0,0,-20),
                          axis.text = element_text(size = 25),
                          axis.title.x = element_text(size = 25))
  grid.plts[[i]] <- grid.plt + annotate("point", x= fwi.scaled[which.max(y),i],  
                                          y=-5.95,
                                          # y=min(xi.smooth$vgam.1[((((i-1)*n)+1):(i*n))]-0.5), 
                                          color = "red", size = 7)
}

library(patchwork)
des <- "
1234
5678
"
grid.plts[[1]] + grid.plts[[2]] + grid.plts[[3]] + grid.plts[[4]] + grid.plts[[5]] + grid.plts[[6]] + grid.plts[[7]] + guide_area() + plot_layout(design = des, guides = "collect")
```



```{r}
load("quant975_prep.Rdata")
load("quant95_prep.Rdata")
qgam::check.qgam(quant.fit)
fwi.df <- data.frame(fwi.scaled, BA=y)
evgam.df <- data.frame(fwi.scaled, BA=y-u)
```



```{r, vgam.scale}
vgam.fit.scale <- vgam(BA ~ sm.ps(DSR) + sm.ps(FWI) + sm.ps(BUI) + sm.ps(ISI) + sm.ps(FFMC) + sm.ps(DMC) + sm.ps(DC),
                        data = fwi.df,
                        family = gpd(threshold = u,
                                      lshape="loglink",
                                      zero = NULL),
                        # trace = TRUE,
                        control = vgam.control(maxit = 200))
par(mfrow = c(2, 4), mar=c(1.75,1.75,1.75,1.75))
plot(vgam.fit.scale, se = TRUE, shade = TRUE, shcol = "steelblue")
par(mfrow = c(1, 1))

fitted.linear <- predict(vgam.fit.scale, newdata = data.frame(xholder), type = "link")
fitted.terms <- predict(vgam.fit.scale, newdata = data.frame(xholder), type = "terms")
vgam.scale.response <- predict(vgam.fit.scale, type = "link")
vgam.xi.scale <- exp(fitted.linear[,2])
grid.val.scale <- plotvgam(vgam.fit.scale,  newdata=xholder, plot.arg=FALSE)@preplot
vgam.smooth.scale <- do.call(cbind, lapply(grid.val.scale[1:p], function(g) g$y))
```

```{r, vgam.1}
vgam.fit.1 <- vgam(BA ~ sm.ps(DSR) + sm.ps(FWI) + sm.ps(BUI) + sm.ps(ISI) + sm.ps(FFMC) + sm.ps(DMC) + sm.ps(DC),
                    data = fwi.df,
                    family = gpd(threshold = u, 
                                  lshape="loglink",
                                  zero = 1),
                    # trace = TRUE,
                    control = vgam.control(maxit = 200))
par(mfrow = c(2, 4), mar=c(1.75,1.75,1.75,1.75))
plot(vgam.fit.1, se = TRUE, shade = TRUE, shcol = "steelblue")
par(mfrow = c(1, 1))
fitted.linear <- predict(vgam.fit.1, newdata = data.frame(xholder), type = "link")
fitted.terms <- predict(vgam.fit.1, newdata = data.frame(xholder), type = "terms")
vgam.1.response <- predict(vgam.fit.1,type="link")

vgam.xi.1 <- exp(fitted.linear[,2])
grid.val.1 <- plotvgam(vgam.fit.1, newdata=xholder, plot.arg=FALSE)@preplot
vgam.smooth.1 <- do.call(cbind, lapply(grid.val.1[1:p], function(g) g$y))
```

```{r, vgam.xi}
vgam.fit.xi <- vgam(BA ~ s(DSR) + s(FWI) + s(BUI) + s(ISI) + s(FFMC) + s(DMC) + s(DC),
                    data = fwi.df,
                    family = gpd(threshold = u, 
                                  lshape="loglink",
                                  zero = 2),
                    trace = TRUE,
                    control = vgam.control(maxit = 200))
par(mfrow = c(2, 4), mar=c(1.75,1.75,1.75,1.75))
plot(vgam.fit.xi, se = TRUE, shade = TRUE, shcol = "steelblue")
par(mfrow = c(1, 1))
fitted.linear <- predict(vgam.fit.xi, newdata = data.frame(xholder), type = "link")
fitted.terms <- predict(vgam.fit.xi, newdata = data.frame(xholder), type = "terms")
fitted.response <- predict(vgam.fit.xi, newdata = data.frame(xholder), type = "response")

```

```{r}
vgam.fit.linear <- vgam(BA ~ .,
                    data = fwi.df,
                    family = gpd(threshold = u, 
                                  lshape="loglink",
                                  zero = NULL),
                    trace = TRUE,
                    control = vgam.control(maxit = 200))
par(mfrow = c(2, 4), mar=c(1.75,1.75,1.75,1.75))
plot(vgam.fit.linear, se = TRUE, shade = TRUE, shcol = "steelblue")
par(mfrow = c(1, 1))
fitted.linear <- predict(vgam.fit.linear, newdata = data.frame(xholder), type = "link")
fitted.terms <- predict(vgam.fit.linear, newdata = data.frame(xholder), type = "terms")
fitted.response <- predict(vgam.fit.linear, newdata = data.frame(xholder), type = "response")
```


```{r}
setwd("C:/Users/Johnny Lee/Documents/GitHub")
load("./BLAST/application/wildfire_prep.Rdata")
# load("./BLAST/application/mqgam_result.Rdata")
load("./BLAST/application/mqgam_result_t.Rdata")
fwi.df <- fwi.origin[which(fwi.origin$BA>1),c(1:8)]
# taus <- c(0.5, 0.75, 0.8, 0.85, 0.9, 0.95, 0.975, 0.99)
taus <- c(0.75, 0.8, 0.825, 0.85, 0.875, 0.9, 0.91, 0.92, 0.93, 0.94, 0.95)
# taus <- c(0.5,0.6, 0.7, 0.8, 0.9, 0.95, 0.975, 0.98, 0.99)
# m.gam <- qgam::mqgam(BA ~ s(DSR, k=30) + s(FWI, k=30) + s(BUI, k=30) + s(ISI, k=30) + s(FFMC, k=30) + s(DMC, k=30) + s(DC, k=30), data = fwi.df, qu = taus)
xholder <- data.frame(sapply(1:p, function(i) seq(min(fwi.df[,i]), max(fwi.df[,i]), length.out = dim(fwi.df)[1])))
# range01 <- function(x){(x-min(x))/(max(x)-min(x))}
# xholder <- as.data.frame(sapply(fwi.df[, c(1:7)], FUN = range01))
colnames(xholder) <- colnames(fwi.df)[1:p]
xholder$BA <- rep(0, dim(xholder)[1])
```

```{r}
library(ggplot2)
library(dplyr)
library(patchwork) # Excellent for combining multiple ggplots

preds_df <- lapply(taus, function(q) {
  data.frame(
    fitted = qdo(m.gam, q, predict, newdata = xholder),
    quantile = as.factor(q) # Convert to factor for coloring
  )
}) %>% bind_rows()

plot_list <- list()

for (j in 1:p) {
  df_points <- data.frame(
    x_val = fwi.df[, j],
    y_val = fwi.df$BA
  )
  df_lines <- preds_df %>%
    mutate(x_val = rep(xholder[, j], length(taus))) # Replicate x for each quantile
  
  var_name <- names(xholder)[j]
  
  plt <- ggplot() +
    geom_point(data = df_points, aes(x = x_val, y = y_val), 
               alpha = 0.3, color = "gray50") +
    geom_line(data = df_lines, aes(x = x_val, y = fitted, color = quantile), 
              linewidth = 0.7) +
    geom_rug(data = df_points, aes(x=x_val, y_val), sides = "b") + 
    scale_color_viridis_d(name = "Quantile") + # Better alternative to rainbow()
    labs(x = var_name, y = "BA") +
    theme_minimal() +
    # theme_minimal(base_size = 25) +
    theme(legend.text = element_text(size = 18),
            legend.title = element_text(size = 18, face="bold"),
            # legend.key.width = unit(0.2, "cm"),
            # legend.key.height = unit(0.8, "cm"),
            plot.margin = margin(0,0,0,-20),
            axis.text = element_text(size = 15),
            axis.title = element_text(size = 25)) 
  plot_list[[length(plot_list) + 1]] <- plt
}

des <- "
1234
5678
"
final.plot <- wrap_plots(plot_list) + guide_area() + plot_layout(design = des, guides = "collect", axis_titles = "collect", axes = "collect_y")
print(final.plot)
```



```{r}
prepare_calibration_data <- function(model, data, response_col, taus, n_bins = 15) {
  all_calib_data <- list()
  for (tau in taus) {
    # Get predictions for specific quantile
    preds <- qdo(model, tau, predict, newdata = data)
    # Create a temporary dataframe for calculation
    tmp_df <- data.frame(
      obs = data[[response_col]],
      pred = preds
    ) %>%
      mutate(
        # Check if observation is effectively below the quantile curve
        is_below = ifelse(obs < pred, 1, 0),
        # Bin the predictions into groups with equal number of observations
        bin = cut_number(pred, n = n_bins) 
      ) %>%
      group_by(bin) %>%
      summarise(
        mean_pred = mean(pred),      # X-axis: Average prediction in this bin
        prop_below = mean(is_below), # Y-axis: Actual proportion below curve
        n = n(),
        .groups = 'drop'
      ) %>%
      mutate(
        quantile = as.factor(tau),
        # Calculate 95% Confidence Intervals for the proportion
        # Standard Error of a proportion = sqrt(p(1-p)/n)
        # We test against the theoretical 'tau'
        se = sqrt((tau * (1 - tau)) / n),
        ci_lower = tau - 1.96 * se,
        ci_upper = tau + 1.96 * se
      )
    
    all_calib_data[[as.character(tau)]] <- tmp_df
  }
  
  bind_rows(all_calib_data)
}
calib_df <- prepare_calibration_data(m.gam, fwi.df, "BA", taus)

# B. Create the ggplot
ggplot(calib_df, aes(x = mean_pred, y = prop_below)) +
  
  # 1. Add Confidence Bands (The "Target" Zone)
  geom_ribbon(aes(ymin = ci_lower, ymax = ci_upper), 
              fill = "blue", alpha = 0.1) +
  
  # 2. Add Target Line (Theoretical Tau)
  geom_hline(aes(yintercept = as.numeric(as.character(quantile))), 
             linetype = "dashed", color = "blue") +
  
  # 3. Add Observed Data Points & Lines
  geom_point() +
  geom_line() +
  
  # 4. Facet by Quantile so each one gets its own scale/plot
  facet_wrap(~quantile, scales = "free", labeller = label_both) +
  
  # 5. Styling
  labs(
    title = "Calibration Check: Observed vs Expected Proportions",
    subtitle = "Points should fall within the shaded confidence bands",
    x = "Predicted Value (Binned)",
    y = "Proportion of Data < Fitted Quantile"
  ) +
  theme(legend.text = element_text(size = 18),
          legend.title = element_text(size = 18, face="bold"),
          # legend.key.width = unit(0.2, "cm"),
          # legend.key.height = unit(0.8, "cm"),
          # plot.margin = margin(0,0,0,-20),
          axis.text = element_text(size = 15),
          axis.title = element_text(size = 25)) 
```


```{r}
library(mgcViz)
print(plot(m.gam, allTerms = TRUE), pages = 1)
```